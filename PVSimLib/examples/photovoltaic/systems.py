#!/usr/bin/env python
# -*- coding: utf-8 -*-

import numpy as np
import photovoltaic.semiconductors as semiconductors
import photovoltaic.solarcells as cell
import photovoltaic.common as common


def light_intensity(J_SC, DNI, DHI):
    """
    Calculate the photocurrent generated by the fraction of light intensity that reaches the surface of the semiconductors module.
    :param J_SC: Photocurrent generated by AMG1.5G (mA cm-2)
    :param DNI: Direct Normal Insolation (W m^-2)
    :param DHI: Diffuse Horizontal Insolation (W m^-2)
    :return: Photocurrent generated (mA cm-2)
    """

    return J_SC*(DNI + DHI)/1000


def power_module_constant_FF(J_L, V_OC, FF):
    """
    Calculate the power generated by the semiconductors module
    :param J_L: Photocurrent generated (mA cm-2)
    :param V_OC: Open Circuit Voltage (V)
    :param FF: Fill factor
    :return: Power generated by the module (W m^-2)
    """
    return 10*J_L*V_OC*FF


def module_temp(DNI, DHI, R_thermal, efficiency, ambient_temperature):
    """
    Calculates the temperature of the module and the deviation from room temperature.
    :param DNI: Direct Normal Insolation (W m^-2)
    :param DHI: Diffuse Horizontal Insolation (W m^-2)
    :param R_thermal:
    :param efficiency:
    :param ambient_temperature:
    :return:
    """
    module_temperature = (DNI + DHI) * R_thermal * (1 - efficiency / 100) + ambient_temperature
    module_temperature_change = module_temperature - 25
    return module_temperature_change, module_temperature


def temp_effect_V(Voc, T):
    """

    :param Voc: Open Circuit Voltage (V)
    :param T: Temperature(V)
    :return: (V/degree C)
    """
    return (semiconductors.Eg0_paessler(1) - Voc + 3*common.Vt(T+273.15))/(T+273.15)


def efficiency (P_module, DNI, DHI):
    """

    :param P_module:
    :param DNI:
    :param DHI:
    :return:
    """
    efficiency = []
    for idx, pdx in zip((DNI + DHI), P_module):
        if idx <= 0:
            efficiency.append(0)
        else:
            efficiency.append(1e5 * pdx / idx)
    return efficiency

def power_module(J_L, J_0, Rseries, module_temperature=None):
    """
    Calculate the power generated by the semiconductors module including Series resistance and temperature effect
    :param J_L: Photocurrent generated (A cm-2)
    :param J_0: Open Circuit Voltage (V)
    :param Rseries: Series Resistance (Ohm cm^2)
    :param module_temperature: Temperatures from TMY (C)
    :return: Power generated by the module (KW m^-2) by day and yearly
    """
    P_module = []
    if module_temperature is None:
        for J_Li in J_L:
            V_OC = cell.Voc(J_Li, J_0)
            voltage = np.linspace(0, V_OC, 100)
            current = cell.I_cell(voltage, J_Li, J_0)
            voltage_r = voltage - current * Rseries
            if (V_OC > 0):
                Voc_r, Jsc_r, FF_r, Vmp_r, Jmp_r, Pmp = cell.cell_params(voltage_r, current)
            else:
                Pmp = 0
            P_module.append(Pmp*10)     # 10 factor coverts W cm^-2 into KW m^-2
        P_yearly_module = sum(P_module)  # KW m^-2
    else:
        for (J_Li, t) in zip(J_L, module_temperature):
            V_OC = cell.Voc(J_Li, J_0)
            voltage = np.linspace(0, V_OC, 100)
            current = cell.I_cell(voltage, J_Li, J_0)
            if(V_OC > 0 ):
                voltage_r = voltage - current * Rseries - temp_effect_V(V_OC, t) * (t-25)
                Voc_r, Jsc_r, FF_r, Vmp_r, Jmp_r, Pmp = cell.cell_params(voltage_r, current)
            else:
                Pmp = 0
            P_module.append(Pmp*10)     # 10 factor coverts W cm^-2 into KW m^-2
        P_yearly_module = sum(P_module)  # KW m^-2

    return P_module, P_yearly_module


def IV_curve_module(JL, J0, Rseries, shading, Vbr, number_series, t=298.15):
    """

    :param JL:
    :param J0:
    :param Rseries:
    :param shading:
    :param Vbr:
    :param number_series:
    :param t:
    :return:
    """
    current = np.linspace(0, JL, 100)
    V_OC = cell.Voc(JL, J0)
    voltage = common.Vt(t) * np.log((JL - 0.99999999999 * current) / J0)
    voltage_r = voltage - current * Rseries
    # IV curve for shaded solar cell
    JL_shaded = JL * (1-shading)
    current_no_zero = np.maximum((JL_shaded - current), 1e-30)
    voltage_positive_shaded = common.Vt(t) * np.log((current_no_zero / J0) + 1)
    voltage_r_positive = voltage_positive_shaded - current_no_zero * Rseries
    reverse_bias_check = np.where(JL_shaded - current > 0, 0, 1)
    voltage_shaded = (1 - reverse_bias_check) * voltage_r_positive + reverse_bias_check * Vbr

    # Combined IV curve
    voltage_total = number_series * voltage_r + voltage_shaded
    Voc_total, Jsc_total, FF_total, Vmp_total, Jmp_total, Pmp_total = cell.cell_params(voltage_total, current)
    return Voc_total, Jsc_total, FF_total, Vmp_total, Jmp_total, Pmp_total, voltage_total, current


def power_module_shaded(JL_module, J0, Rseries, shading, Vbr, number_series, t = 298.15):
    """

    :param JL_module:
    :param J0:
    :param Rseries:
    :param shading:
    :param Vbr:
    :param number_series:
    :param t:
    :return:
    """
    # Initialize arrays with power from the unshaded and shaded combination every hour of the year
    P_module_unshaded = np.zeros(len(JL_module))
    P_module_total = np.zeros(len(JL_module))
    # Loop through every hour of the year, get the light generated current, and find the 3 IV curves
    # idx is indexing parameter for hours of the year, JLm is light generated current for that hour of the year
    for idx, JLm in enumerate(JL_module):
        if JLm > 0:
            # Since we have series connected cells, we increment current and find voltage
            # (harder than a single IV curve where we loop on V).
            current = np.linspace(0, JLm, 100)  # Define currents in IV curve
            V_OC = cell.Voc(JLm, J0)
            # IV curve for unshaded solar cell
            voltage = (common.Vt(t) * np.log((JLm - 0.99999999999 * current) / J0)) - current * Rseries
            Voc_unshaded, Jsc_unshaded, FF_unshaded, Vmp_unshaded, Jmp_unshaded, Pmp_unshaded = \
                cell.cell_params(voltage, current)
            P_module_unshaded[idx] = Pmp_unshaded * 10

            # IV curve for shaded solar cell
            JL_shaded = JLm * (1-shading)
            current_no_zero = np.maximum((JL_shaded - current), 1e-30)
            voltage_r_positive = (common.Vt(t) * np.log((current_no_zero / J0) + 1)) - current_no_zero * Rseries

            reverse_bias_check = np.where(JL_shaded - current > 0, 0, 1)
            voltage_shaded = (1 - reverse_bias_check) * voltage_r_positive + reverse_bias_check * Vbr

            # Combined IV curve
            voltage_total = number_series * voltage + voltage_shaded
            Voc_total, Jsc_total, FF_total, Vmp_total, Jmp_total, Pmp_total = cell.cell_params(voltage_total,
                                                                                             current)
            P_module_total[idx] = Pmp_total * 10
        else:
            P_module_unshaded[idx] = 0
            P_module_total[idx] = 0

    # Calcualte total power depending on when shading occurs

    P_yearly_module_unshaded = sum(P_module_unshaded)
    P_yearly_module_shaded = sum(P_module_total) / (number_series + 1)  # kWh/mÂ²
    return P_yearly_module_unshaded, P_yearly_module_shaded
